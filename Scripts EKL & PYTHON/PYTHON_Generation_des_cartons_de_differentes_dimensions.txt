import tkinter as tk 
from tkinter import filedialog, messagebox
import pandas as pd

def browse_file():
    file_path = filedialog.askopenfilename(
        filetypes=[("CSV files", "*.csv")],
        title="Select a CSV file"
    )
    if file_path:
        try:
            df = pd.read_csv(file_path)   # la 1re ligne est l’en-tête
            messagebox.showinfo("Success", f"CSV imported successfully!\nShape: {df.shape}")
            print(df.head())              # Aperçu console
            # <<< clé: stocker DF sur root, sans global >>>
            root.DF = df
            # fermer la fenêtre pour sortir du mainloop et continuer le script
            root.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load CSV:\n{e}")

# Create the main window
root = tk.Tk()
root.title("CSV Loader")
root.DF = None  # <<< init >>>

# Create a button to browse files
browse_button = tk.Button(root, text="Browse CSV", command=browse_file)
browse_button.pack(padx=20, pady=20)

# Start the GUI loop (le script continue après fermeture de la fenêtre)
root.mainloop()

#  APRÈS fermeture de la fenêtre 
DF = root.DF
if DF is None:
    raise RuntimeError("Aucun CSV n'a été chargé. Relance et clique sur 'Browse CSV'.")

# normalise les noms de colonnes
DF.columns = [c.strip().lower() for c in DF.columns]
required = ["length","width","height"]
missing = [c for c in required if c not in DF.columns]
if missing:
    raise ValueError(f"Colonnes manquantes dans le CSV : {missing}. Attendu: length,width,height.")

# nettoie et enlève les lignes vides
df_clean = DF[required].copy()
# convertit textos éventuels "0,3" -> "0.3", "300 mm" -> "300"
for col in required:
    df_clean[col] = (
        df_clean[col].astype(str)
                      .str.replace("mm","", case=False)
                      .str.replace(",",".")
                      .str.strip()
    )
    df_clean[col] = pd.to_numeric(df_clean[col], errors="coerce")

df_clean = df_clean.dropna(how="any").reset_index(drop=True)

# construit Tool_list = [[L,W,H], ...]
Tool_list = df_clean[["length","width","height"]].values.tolist()


#  Boucle à l'index k (un carton par ligne)

print("Tool_list =", Tool_list)

for k in range(len(Tool_list)):
    # récupère L,W,H pour ce carton k
    lengthBox = float(Tool_list[k][0])
    widthBox  = float(Tool_list[k][1])
    heightBox = float(Tool_list[k][2])

    # décommente si tes valeurs sont en mètres et que le template attend des mm 
    # lengthBox *= 1000.0
    # widthBox  *= 1000.0
    # heightBox *= 1000.0

    # Type + nom unique
    TypeOfResource = "Package"
    NameRes = TypeOfResource + str(k)

    # Décale Y pour visualiser chaque carton (évite la superposition)
    Xcoord = 0
    Ycoord = 1000 * k  # 1 m d'écart entre cartons

    WarehouseRef = ekl.GetEditorRoots("VPMReference").GetItem(1)

    # Instantiation de la boite avec les bonnes dimensions
    BoxInst = ekl.new("VPMReference", NameRes, WarehouseRef)
    BoxRef = BoxInst.Reference
    template = ekl.InstantiateTemplate("tpl_box", BoxRef)
    template.SetAttributeDimension("length", lengthBox, "LENGTH")
    template.SetAttributeDimension("width",  widthBox,  "LENGTH")
    template.SetAttributeDimension("height", heightBox, "LENGTH")
    ekl.EndModifyTemplate(template)

    # Positionnement de la boite dans l'espace
    M0 = [[0.99, 0.005, 0.005, Xcoord],
          [0.005, 0.99, 0.005, Ycoord],
          [0.005, 0.005, 0.99, 0],
          [0,     0,     0,    0]]
    EKL_Matrix = ekl.Matrix(M0)
    BoxInst.PositionMatrix = EKL_Matrix

    WarehouseRef.UpdateListOccurrences()
    ListOcc = BoxRef.ListOccurrences(WarehouseRef)
    for i in ListOcc:
        MainProductOcc = i

    # création du bon type de ressource
    MyRscControllerMgr = ekl.types.RscControllerMgr(MainProductOcc.GetRscControllerMgr())
    _ = MyRscControllerMgr.SetRscModelTypeID(TypeOfResource)
